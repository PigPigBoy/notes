# 锁

## 分类
### （1）表锁
- 开销小，加锁快
- 不会出现死锁
- 粒度大，锁冲突高，并发度低
- 适合查询为主
### （2）行锁
- 开销大，加锁慢
- 会出现死锁
- 粒度小，锁冲突低，并发度高
### （3）页面锁
- 会出现死锁
- 锁开销、速度、粒度、并发度都介于行锁和表锁之间
### （4）读锁
### （5）写锁

<br />

## MySQL锁
## 相对于其他的数据库，mysql锁机制很简单。显著特点是不同的存储引擎支持有不同的锁机制

存储引擎|表锁|行锁|页面锁
:-:|:-:|:-:|:-:|
MyISAM|✔|✖|✖
InnoDB|✔|✔|✖
Memory|✔|✖|✖
BDB|✔|✖|✔

## MyISAM表锁
- `MyISAM只支持表锁`
- select 自动加读锁
- update、delete、insert 自动写锁
- 写优先。获取写后，其他线程不能做任何操作。因此不适合写多场景
- 显示加锁语法
```sql
    lock table table_name read;
    lock table table_name write;
```
- 读锁
  - 不会阻塞其他线程的读操作，但是会阻塞其他线程的写操作
  - 对a表上锁，就无法操作b表。可以理解为：12306抢了一张火车票，还未付款，就无法抢另外一张火车票
  - 一个线程，对a表上`读`锁，无法继续更新a表
  - 其他线程更新a表，会阻塞等待，直到解除读锁

- 写锁
  - a表加了写锁，也能进行读写
  - 其他线程读取a表，会阻塞等待，直到解除写锁

- 读写锁小结
  - 读锁会阻塞写，写锁会阻塞读
  - 只有读读锁才可以兼容


## 查看锁的争用情况
- `show open tables`
  - 不同数据库的表、是否被使用、表名是否被锁定
  - 哪张表被使用可以间接判定哪张表被加锁
  - 表名锁定用于重命名等操作
  
![](/others/pictures/show_open_tables.jpg)
  
- `show status like 'Table_locks%'`
  - Table_locks_immediate：立刻获取表锁次数，每次获取+1
  - Table_locks_waited：不能立即获取锁需要等待的次数，每等待一次+1。此值高说明表锁争用严重

![](/others/pictures/table_locks.jpg)

<br />

## InnoDB行锁
- 特点
  - 开销大
  - 加锁慢
  - 会出现死锁
  - 粒度小
  - 锁冲突概率低
  - 并发高
- InnoDB与MyISAM最大的两个不同点
  - 事务
  - 行锁
- select不会加锁
- t1线程对表A的id=1那一行数据进行更新，t2线程也对这一行数据更新，t2线程会阻塞等待，直到t1线程的事务提交


## InnoDB锁升级
- 无索引行锁升级为表锁
- 如果`不通过索引`检索，那么InnoDB需要对表的所有记录加锁，实际效果与表锁一样
- 因此在写sql时候注意，where后面字段没有用到索引就会导致行锁升级为表锁

## 间隙锁
### 在进行范围查询时，InnoDB会对符合条件的所有数据都会加锁。`不存在的数据也会加锁`，这种叫做间隙锁（Next-key）
- 尽量避免
- where条件缩小范围，比如 `id < 1000` 写成 `100 < id < 1000`

```sql
  # 假设只2条数据 id = 1,2
  # innodb会对id=1,2,3 三条记录全部加锁，即使id=3不存在
  # 此时另一个线程插入一条id=3的数据是`无法插入`的，因为id=3这条记录已经被锁定了
  update tb set a = 1 where id < 4
```
- 查看行锁争用的情况
  - `show status like 'innodb_row_lock'`
  - 参数
    - Innodb_row_lock_current_waits：当前等待行锁的数量
    - Innodb_row_lock_time：锁定的总时长
    - Innodb_row_lock_time_avg：锁定的平均时长
    - Innodb_row_lock_time_max：锁定的最大时长
    - Innodb_row_lock_waits：系统启动后，到现在，总共等待的次数
    - 当`等待次数`很高，`等待时间`也很长，就需要进行分析优化 

![](/others/pictures/innodb_row_lock.jpg)

- 总结
  - InnoDB默认支持行锁
  - 虽然在锁机制方面的性能损耗较大，但是并发处理方面远优于MyISAM
  - `使用不当，可能会让InnoDB整体性能反而更差`
  - 优化建议
    - 检索尽量走索引，`避免锁升级`
    - 合理设计索引，减少锁的范围
      - 假设有索引列 idx_a_b_c，每次更新a列数据时，不仅更新那一行数据，也要更新B+数上对应的`一块叶子节点a,b,c`
      - 假设有单值索引 idx_a，每次更新a列数据时，不仅更新那一行数据，也要更新B+数上对应的`一块叶子节点a`
      - 发现更新索引的范围更小了
    - 减少索引条件、缩小索引范围，`避免间隙锁`
    - 控制事务大小（一次事务操作不要操作过多的表），`减小锁占用资源`
    - 满足业务需求下，`降低事务隔离级别`